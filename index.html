<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NWS Weather App</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --bg-color: #f3f4f6;
      --text-color: #1f2937;
      --header-bg: linear-gradient(to right, #4b91f1, #a3bffa);
      --header-text: #ffffff;
      --card-bg: #ffffff;
      --border-color: #e5e7eb;
      --shadow: rgba(0, 0, 0, 0.1);
    }
    [data-theme="dark"] {
      --bg-color: #1f2937;
      --text-color: #e5e7eb;
      --header-bg: linear-gradient(to right, #1e40af, #4b5563);
      --header-text: #e5e7eb;
      --card-bg: #374151;
      --border-color: #4b5563;
      --shadow: rgba(0, 0, 0, 0.3);
    }
    body {
      background: var(--bg-color);
      color: var(--text-color);
      margin: 0;
      font-family: sans-serif;
    }
    .header {
      background: var(--header-bg);
      color: var(--header-text);
      padding: 16px;
      position: fixed;
      top: 0;
      width: 100%;
      height: 60px;
      box-shadow: 0 2px 4px var(--shadow);
    }
    .tabs {
      display: flex;
      position: fixed;
      top: 60px;
      width: 100%;
      background: var(--card-bg);
      padding: 8px 0;
      box-shadow: 0 2px 4px var(--shadow);
    }
    .tab-button {
      flex: 1;
      text-align: center;
      padding: 8px;
      cursor: pointer;
      font-weight: 500;
      color: #4b91f1;
    }
    .tab-button.active {
      color: #1e40af;
      border-bottom: 2px solid #1e40af;
    }
    .tab-content {
      display: none;
      padding: 16px;
      margin-top: 116px;
      height: calc(100vh - 116px);
      overflow-y: auto;
    }
    .tab-content.active {
      display: block;
    }
    .settings-section, .alerts-section {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      background: var(--bg-color);
      z-index: 30;
    }
    .settings-section.active, .alerts-section.active {
      display: block;
    }
    .settings-header, .alerts-header {
      background: var(--header-bg);
      color: var(--header-text);
      padding: 16px;
      position: fixed;
      top: 0;
      width: 100%;
      display: flex;
      align-items: center;
    }
    .settings-content, .alerts-content {
      margin-top: 60px;
      padding: 16px;
      overflow-y: auto;
      height: calc(100vh - 60px);
    }
    .settings-toggle {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
    }
    .autocomplete-dropdown {
      position: absolute;
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 0.375rem;
      max-height: 200px;
      overflow-y: auto;
      width: 100%;
      box-shadow: 0 4px 6px var(--shadow);
      z-index: 20;
    }
    .autocomplete-item {
      padding: 8px;
      cursor: pointer;
    }
    .autocomplete-item:hover {
      background-color: var(--border-color);
    }
    .alert-item {
      padding: 8px;
      border-bottom: 1px solid var(--border-color);
    }
    .alert-item:last-child {
      border-bottom: none;
    }
    .alert-title {
      cursor: pointer;
      font-weight: 600;
      color: #dc2626;
    }
    .alert-title:hover {
      color: #b91c1c;
    }
    .alert-description {
      display: none;
      margin-top: 4px;
      font-size: 0.875rem;
    }
    .alert-description.active {
      display: block;
    }
    .badge {
      position: absolute;
      top: -8px;
      right: -8px;
      background: #ef4444;
      color: white;
      border-radius: 9999px;
      padding: 2px 6px;
      font-size: 12px;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    .hour-row {
      display: flex;
      padding: 8px 0;
      border-bottom: 1px solid var(--border-color);
      overflow-x: auto;
    }
    .hour-cell {
      flex: 0 0 auto;
      min-width: 80px;
      padding: 4px;
      text-align: center;
    }
    @media (max-width: 640px) {
      .hour-cell {
        min-width: 60px;
        font-size: 0.85rem;
      }
    }
    .day-item {
      padding: 8px 0;
      border-bottom: 1px solid var(--border-color);
    }
    .day-item:last-child {
      border-bottom: none;
    }
    .starter-screen {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      text-align: center;
    }
    .weather-card {
      background: linear-gradient(135deg, #ffffff50, #e0e7ff50);
      border-radius: 1rem;
      padding: 16px;
      box-shadow: 0 4px 6px var(--shadow);
      max-width: 600px;
      margin: 0 auto;
    }
    [data-theme="dark"] .weather-card {
      background: linear-gradient(135deg, #37415150, #4b556350);
    }
    [data-theme="dark"] input#location {
      background-color: #4b5563;
      color: #ffffff;
    }
    .weather-card .bg-white\/80 {
      background: #ffffff50;
      color: var(--text-color);
    }
    [data-theme="dark"] .weather-card .bg-white\/80 {
      background: #1f293750;
      color: var(--text-color);
    }
    #frame {
      width: 100%;
      height: calc(100vh - 116px);
      border: none;
      display: block;
    }
  </style>
</head>
<body>
  <div class="header flex justify-between items-center">
    <h1 id="location-name-header" class="text-xl font-bold cursor-pointer">Select Location</h1>
    <div class="flex items-center">
      <button id="alerts-button" class="relative mr-4">
        <svg class="w-6 h-6 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
        </svg>
        <span id="alerts-count" class="badge hidden">0</span>
      </button>
      <button id="settings-button" class="text-white hover:text-gray-200">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37 1 .608 2.296.07 2.572-1.065z"></path>
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
        </svg>
      </button>
    </div>
  </div>
  <div class="tabs hidden" id="tabs">
    <div class="tab-button active" data-tab="now">Now</div>
    <div class="tab-button" data-tab="hourly">Hourly</div>
    <div class="tab-button" data-tab="7-day">7-Day</div>
    <div class="tab-button" data-tab="station-search">Station Search</div>
  </div>
  <div id="starter-screen" class="starter-screen">
    <h1 class="text-2xl font-bold mb-4">Weather App</h1>
    <div id="geolocation-message" class="hidden text-gray-600 mb-4">Please allow location access...</div>
    <div class="w-3/4">
      <label for="location" class="block text-sm font-medium">Enter Address or Zip Code</label>
      <input type="text" id="location" placeholder="Address or Zip Code" class="mt-1 block w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-600 bg-white" autocomplete="off">
      <div id="autocomplete-dropdown" class="autocomplete-dropdown hidden"></div>
      <p id="location-error" class="text-red-500 text-sm mt-1 hidden"></p>
    </div>
    <div class="flex gap-2 mt-4">
      <button id="get-weather" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700">Get Forecast</button>
      <button id="auto-locate" class="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700">Auto-Locate</button>
    </div>
  </div>
  <div id="loading" class="hidden text-center mt-4">
    <p class="text-gray-600">Loading...</p>
  </div>
  <div id="weather-result" class="hidden">
    <div id="now-section" class="tab-content active"></div>
    <div id="hourly-section" class="tab-content"></div>
    <div id="7-day-section" class="tab-content"></div>
    <div id="station-search-section" class="tab-content">
      <iframe id="frame"></iframe>
    </div>
  </div>
  <div id="alerts-section" class="alerts-section hidden">
    <div class="alerts-header">
      <button id="alerts-back" class="text-gray-600 hover:text-gray-800">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
        </svg>
      </button>
      <h3 class="text-lg font-medium ml-2">Active Alerts</h3>
    </div>
    <div id="alerts-content" class="alerts-content">
      <div id="alerts-list"></div>
    </div>
  </div>
  <div id="settings-section" class="settings-section hidden">
    <div class="settings-header">
      <button id="settings-back" class="text-gray-600 hover:text-gray-800">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
        </svg>
      </button>
      <h3 class="text-lg font-medium ml-2">Settings</h3>
    </div>
    <div class="settings-content">
      <div class="settings-toggle">
        <span>Dark Mode</span>
        <label class="relative inline-flex items-center cursor-pointer">
          <input type="checkbox" id="theme-toggle" class="sr-only peer">
          <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:bg-blue-600"></div>
          <div class="absolute w-4 h-4 bg-white rounded-full top-1 left-1 peer-checked:translate-x-5"></div>
        </label>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const API_KEY = '86f857c7c80b4ba3bfe3afdb9fefb393';
      const GEOCODING_API = 'https://api.opencagedata.com/geocode/v1/json';
      const NWS_API = 'https://api.weather.gov';
      let selectedLocation = null;
      let currentLocation = null;

      const savedTheme = localStorage.getItem('theme') || 'light';
      document.documentElement.setAttribute('data-theme', savedTheme);
      document.getElementById('theme-toggle').checked = savedTheme === 'dark';

      const stationSearchIframe = document.getElementById('frame');
      fetch('https://cdn.jsdelivr.net/gh/austin102909/station-search/index.html')
        .then(res => res.ok ? res.text() : Promise.reject())
        .then(html => { stationSearchIframe.srcdoc = html; })
        .catch(() => { document.getElementById('station-search-section').innerHTML = '<p class="text-red-500">Error loading Station Search.</p>'; });

      stationSearchIframe.addEventListener('load', () => {
        if (!stationSearchIframe.contentWindow.document.body.innerHTML) {
          document.getElementById('station-search-section').innerHTML = '<p class="text-red-500">Error loading Station Search.</p>';
        }
      });

      const debounce = (fn, delay) => {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => fn(...args), delay);
        };
      };

      const fetchWithRetry = async (url, retries = 3) => {
        for (let i = 0; i < retries; i++) {
          try {
            const response = await fetch(url, { headers: { 'User-Agent': 'NWS Weather App', 'accept': 'application/geo+json' } });
            if (response.status === 429) {
              await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
              continue;
            }
            if (!response.ok) throw new Error();
            return response;
          } catch {
            if (i === retries - 1) throw new Error();
          }
        }
      };

      const getCachedData = (key) => {
        const cached = JSON.parse(localStorage.getItem(key));
        if (cached && Date.now() - cached.timestamp < 15 * 60 * 1000) return cached.data;
        return null;
      };

      const setCachedData = (key, data) => {
        localStorage.setItem(key, JSON.stringify({ data, timestamp: Date.now() }));
      };

      const reverseGeocode = async (lat, lng) => {
        const cacheKey = `${lat}_${lng}`;
        const cached = getCachedData(cacheKey);
        if (cached) return cached;
        const response = await fetchWithRetry(`${GEOCODING_API}?q=${lat}+${lng}&key=${API_KEY}&countrycode=US&limit=1`);
        const data = await response.json();
        if (!data.results.length) throw new Error();
        const result = data.results[0].formatted.replace(/United States of America/, 'U.S.');
        setCachedData(cacheKey, result);
        return result;
      };

      const getHumidity = async (wfo, gridX, gridY, startTime) => {
        const cacheKey = `${wfo}_${gridX}_${gridY}`;
        let humidityData = getCachedData(cacheKey);
        if (!humidityData) {
          const response = await fetchWithRetry(`${NWS_API}/gridpoints/${wfo}/${gridX},${gridY}`);
          humidityData = (await response.json()).properties.relativeHumidity.values;
          setCachedData(cacheKey, humidityData);
        }
        const targetTime = new Date(startTime).getTime();
        let closest = 'N/A';
        let minDiff = Infinity;
        for (const entry of humidityData) {
          const entryTime = new Date(entry.validTime.split('/')[0]).getTime();
          const diff = Math.abs(targetTime - entryTime);
          if (diff < minDiff) {
            minDiff = diff;
            closest = entry.value;
          }
        }
        return closest !== 'N/A' ? `${closest}%` : 'N/A';
      };

      const fetchGeocoding = async (location) => {
        const cacheKey = location.toLowerCase().replace(/\s+/g, '_');
        const cached = getCachedData(cacheKey);
        if (cached) return cached;
        const response = await fetchWithRetry(`${GEOCODING_API}?q=${encodeURIComponent(location)}&key=${API_KEY}&countrycode=US&limit=5`);
        const data = await response.json();
        if (!data.results.length) throw new Error();
        const result = {
          lat: data.results[0].geometry.lat,
          lng: data.results[0].geometry.lng,
          name: data.results[0].components.city || data.results[0].formatted.replace(/United States of America/, 'U.S.')
        };
        setCachedData(cacheKey, result);
        return result;
      };

      const fetchCurrentConditions = async (stationsUrl, wfo, gridX, gridY) => {
        const stationsResponse = await fetchWithRetry(stationsUrl);
        const stationsData = await stationsResponse.json();
        const stationId = stationsData.features[0].properties.stationIdentifier;
        const obsResponse = await fetchWithRetry(`${NWS_API}/stations/${stationId}/observations/latest`);
        const obsData = await obsResponse.json();
        const humidity = await getHumidity(wfo, gridX, gridY, new Date().toISOString());
        return { obsData, humidity };
      };

      const fetchHourlyForecast = async (wfo, gridX, gridY) => {
        const cacheKey = `hourly_${wfo}_${gridX}_${gridY}`;
        let hourlyData = getCachedData(cacheKey);
        if (!hourlyData) {
          const response = await fetchWithRetry(`${NWS_API}/gridpoints/${wfo}/${gridX},${gridY}/forecast/hourly`);
          hourlyData = await response.json();
          setCachedData(cacheKey, hourlyData);
        }
        return hourlyData;
      };

      const fetchSevenDayForecast = async (wfo, gridX, gridY) => {
        const cacheKey = `7day_${wfo}_${gridX}_${gridY}`;
        let forecastData = getCachedData(cacheKey);
        if (!forecastData) {
          const response = await fetchWithRetry(`${NWS_API}/gridpoints/${wfo}/${gridX},${gridY}/forecast`);
          forecastData = await response.json();
          setCachedData(cacheKey, forecastData);
        }
        return forecastData;
      };

      const fetchAlerts = async (lat, lng) => {
        const response = await fetchWithRetry(`${NWS_API}/alerts/active?point=${lat},${lng}`);
        return (await response.json()).features || [];
      };

      const elements = {
        locationInput: document.getElementById('location'),
        autocomplete: document.getElementById('autocomplete-dropdown'),
        locationError: document.getElementById('location-error'),
        starter: document.getElementById('starter-screen'),
        result: document.getElementById('weather-result'),
        tabs: document.getElementById('tabs'),
        settings: document.getElementById('settings-section'),
        alerts: document.getElementById('alerts-section')
      };

      elements.locationInput.addEventListener('input', debounce(async () => {
        const query = elements.locationInput.value.trim();
        if (query.length < 3) {
          elements.autocomplete.classList.add('hidden');
          elements.locationError.classList.add('hidden');
          return;
        }
        try {
          const response = await fetchWithRetry(`${GEOCODING_API}?q=${encodeURIComponent(query)}&key=${API_KEY}&countrycode=US&limit=5`);
          const data = await response.json();
          elements.autocomplete.innerHTML = '';
          if (data.results.length) {
            data.results.forEach(result => {
              const formatted = result.formatted.replace(/United States of America/, 'U.S.');
              const item = document.createElement('div');
              item.className = 'autocomplete-item';
              item.textContent = formatted;
              item.addEventListener('click', () => {
                elements.locationInput.value = formatted;
                selectedLocation = result;
                elements.autocomplete.classList.add('hidden');
                elements.locationError.classList.add('hidden');
                fetchWeather(formatted);
              });
              elements.autocomplete.appendChild(item);
            });
            elements.autocomplete.classList.remove('hidden');
          } else {
            elements.autocomplete.classList.add('hidden');
            elements.locationError.textContent = 'No locations found.';
            elements.locationError.classList.remove('hidden');
          }
        } catch {
          elements.autocomplete.classList.add('hidden');
          elements.locationError.textContent = 'Error fetching locations.';
          elements.locationError.classList.remove('hidden');
        }
      }, 300));

      document.addEventListener('click', (e) => {
        if (!elements.locationInput.contains(e.target) && !elements.autocomplete.contains(e.target) && !document.getElementById('location-name-header').contains(e.target)) {
          elements.autocomplete.classList.add('hidden');
        }
        if (!document.getElementById('alerts-button').contains(e.target) && !elements.alerts.contains(e.target)) {
          elements.alerts.classList.remove('active');
        }
      });

      document.getElementById('location-name-header').addEventListener('click', () => {
        if (currentLocation) {
          elements.locationInput.value = currentLocation;
          elements.starter.classList.remove('hidden');
          elements.result.classList.add('hidden');
          elements.settings.classList.add('hidden');
          elements.alerts.classList.remove('active');
          elements.tabs.classList.add('hidden');
          elements.autocomplete.classList.remove('hidden');
        }
      });

      document.querySelectorAll('.tab-button').forEach(button => {
        button.addEventListener('click', () => {
          document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
          button.classList.add('active');
          const tabSection = document.getElementById(`${button.dataset.tab}-section`);
          if (tabSection) tabSection.classList.add('active');
          elements.settings.classList.add('hidden');
          elements.alerts.classList.remove('active');
        });
      });

      const navigateBack = () => {
        elements.settings.classList.remove('active');
        elements.alerts.classList.remove('active');
        if (currentLocation) {
          elements.result.classList.remove('hidden');
          elements.tabs.classList.remove('hidden');
        } else {
          elements.starter.classList.remove('hidden');
        }
      };

      document.getElementById('alerts-button').addEventListener('click', () => {
        elements.alerts.classList.toggle('active');
        elements.settings.classList.add('hidden');
        elements.starter.classList.add('hidden');
        elements.result.classList.add('hidden');
        elements.tabs.classList.add('hidden');
      });

      document.getElementById('alerts-back').addEventListener('click', navigateBack);
      document.getElementById('settings-button').addEventListener('click', () => {
        elements.starter.classList.add('hidden');
        elements.result.classList.add('hidden');
        elements.alerts.classList.remove('active');
        elements.tabs.classList.add('hidden');
        elements.settings.classList.add('active');
      });

      document.getElementById('settings-back').addEventListener('click', navigateBack);

      document.getElementById('theme-toggle').addEventListener('change', (e) => {
        const theme = e.target.checked ? 'dark' : 'light';
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
      });

      async function fetchWeather(location, lat, lng, isGeolocation = false) {
        const elements = {
          error: document.getElementById('location-error'),
          loading: document.getElementById('loading'),
          starter: document.getElementById('starter-screen'),
          result: document.getElementById('weather-result'),
          tabs: document.getElementById('tabs'),
          now: document.getElementById('now-section'),
          hourly: document.getElementById('hourly-section'),
          sevenDay: document.getElementById('7-day-section'),
          header: document.getElementById('location-name-header'),
          alertsList: document.getElementById('alerts-list'),
          alertsCount: document.getElementById('alerts-count')
        };

        if (!elements.sevenDay) {
          console.warn('Element with id "7-day-section" not found in DOM.');
          return;
        }

        if (!isGeolocation && !location) {
          elements.error.textContent = 'Please enter a location.';
          elements.error.classList.remove('hidden');
          return;
        }

        elements.error.classList.add('hidden');
        elements.loading.classList.remove('hidden');
        elements.starter.classList.add('hidden');
        elements.result.classList.add('hidden');

        try {
          let locationName;
          if (isGeolocation) {
            locationName = location;
          } else if (selectedLocation && selectedLocation.formatted.replace(/United States of America/, 'U.S.') === location) {
            lat = selectedLocation.geometry.lat;
            lng = selectedLocation.geometry.lng;
            locationName = selectedLocation.formatted.replace(/United States of America/, 'U.S.');
          } else {
            const geoData = await fetchGeocoding(location);
            lat = geoData.lat;
            lng = geoData.lng;
            locationName = geoData.name;
          }
          lat = Number(lat.toFixed(4));
          lng = Number(lng.toFixed(4));

          const pointsResponse = await fetchWithRetry(`${NWS_API}/points/${lat},${lng}`);
          const pointsData = await pointsResponse.json();
          const stationsUrl = pointsData.properties.observationStations;
          const wfo = pointsData.properties.gridId;
          const gridX = pointsData.properties.gridX;
          const gridY = pointsData.properties.gridY;

          const { obsData, humidity } = await fetchCurrentConditions(stationsUrl, wfo, gridX, gridY);
          const currentTempF = obsData.properties.temperature?.value != null ? Math.round((obsData.properties.temperature.value * 9/5) + 32) : 'N/A';
          const currentConditions = obsData.properties.textDescription || 'N/A';
          const windSpeed = obsData.properties.windSpeed?.value ? `${Math.round(obsData.properties.windSpeed.value * 0.621371)} mph` : 'N/A';
          const windDirection = obsData.properties.windDirection?.value != null ? ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'][Math.round(obsData.properties.windDirection.value / 45) % 8] : 'N/A';
          const windGust = obsData.properties.windGust?.value ? `${Math.round(obsData.properties.windGust.value * 0.621371)} mph` : 'N/A';
          const dewPointF = obsData.properties.dewpoint?.value != null ? Math.round((obsData.properties.dewpoint.value * 9/5) + 32) : 'N/A';
          const pressure = obsData.properties.seaLevelPressure?.value ? `${(obsData.properties.seaLevelPressure.value / 100).toFixed(2)} hPa` : 'N/A';
          const visibility = obsData.properties.visibility?.value ? `${Math.min(Math.round(obsData.properties.visibility.value / 1609.34), 10)} mi` : 'N/A';
          const feelsLikeF = obsData.properties.heatIndex?.value != null ? Math.round((obsData.properties.heatIndex.value * 9/5) + 32) : currentTempF;
          const rainToday = obsData.properties.precipitationLast24Hours?.value ? `${(obsData.properties.precipitationLast24Hours.value * 0.0393701).toFixed(2)} in` : 'N/A';
          const lastUpdated = obsData.properties.timestamp ? new Date(obsData.properties.timestamp).toLocaleString() : 'N/A';

          const hourlyData = await fetchHourlyForecast(wfo, gridX, gridY);
          const alerts = await fetchAlerts(lat, lng);
          const forecastData = await fetchSevenDayForecast(wfo, gridX, gridY);
          const periods = forecastData.properties.periods;

          elements.header.textContent = locationName;
          currentLocation = locationName;
          elements.now.innerHTML = `
            <div class="weather-card">
              <div class="grid grid-cols-1 gap-4 text-center">
                <p class="text-6xl font-extrabold text-blue-600 dark:text-blue-400">${currentTempF}°F</p>
                <img src="${obsData.properties.icon || `${NWS_API}/icons/land/day/skc?size=medium`}" alt="${currentConditions}" class="mx-auto w-24 h-24">
                <p class="text-xl font-semibold">${currentConditions}</p>
              </div>
              <div class="grid grid-cols-2 gap-4 mt-4">
                <div class="bg-white/80 p-3 rounded-lg shadow">
                  <p class="text-base">Feels Like: <span class="text-blue-500 dark:text-blue-400">${feelsLikeF}°F</span></p>
                  <p class="text-base">Humidity: <span class="text-green-500 dark:text-green-400">${humidity}</span></p>
                  <p class="text-base">Dew Point: <span class="text-purple-500 dark:text-purple-400">${dewPointF}°F</span></p>
                  <p class="text-base">Visibility: <span class="text-indigo-500 dark:text-indigo-400">${visibility}</span></p>
                </div>
                <div class="bg-white/80 p-3 rounded-lg shadow">
                  <p class="text-base">Wind: <span class="text-yellow-500 dark:text-yellow-400">${windSpeed} ${windDirection}</span></p>
                  <p class="text-base">Wind Gust: <span class="text-yellow-500 dark:text-yellow-400">${windGust}</span></p>
                  <p class="text-base">Pressure: <span class="text-red-500 dark:text-red-400">${pressure}</span></p>
                  <p class="text-base">Rain Today: <span class="text-teal-500 dark:text-teal-400">${rainToday}</span></p>
                </div>
              </div>
              <div class="bg-white/80 p-3 rounded-lg shadow mt-4">
                <p class="text-base">Last Updated: <span>${lastUpdated}</span></p>
                <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">Coordinates: ${lat.toFixed(4)}, ${lng.toFixed(4)}</p>
              </div>
            </div>
          `;

          elements.hourly.innerHTML = '';
          const now = new Date();
          const twentyFourHoursLater = new Date(now.getTime() + 24 * 60 * 60 * 1000);
          const hourlyPeriods = hourlyData.properties.periods.filter(period => {
            const periodTime = new Date(period.startTime);
            return periodTime >= now && periodTime <= twentyFourHoursLater;
          }).slice(0, 24);
          for (const period of hourlyPeriods) {
            const timeStr = new Date(period.startTime).toLocaleTimeString([], { hour: 'numeric', hour12: true });
            const humidity = await getHumidity(wfo, gridX, gridY, period.startTime);
            const chanceOfRain = period.probabilityOfPrecipitation?.value ? `${period.probabilityOfPrecipitation.value}%` : 'N/A';
            const tempF = period.temperatureUnit === 'F' ? period.temperature : Math.round((period.temperature * 9/5) + 32);
            const row = document.createElement('div');
            row.className = 'hour-row';
            row.innerHTML = `
              <div class="hour-cell font-medium">${timeStr}</div>
              <div class="hour-cell">${tempF}°F</div>
              <div class="hour-cell"><img src="${period.icon || `${NWS_API}/icons/land/day/skc?size=medium`}" alt="${period.shortForecast || 'Clear'}" class="mx-auto w-10 h-10"></div>
              <div class="hour-cell">${period.shortForecast || 'N/A'}</div>
              <div class="hour-cell">Rain: ${chanceOfRain}</div>
              <div class="hour-cell">Humidity: ${humidity}</div>
            `;
            elements.hourly.appendChild(row);
          }

          elements.sevenDay.innerHTML = '';
          let dayCount = 0;
          let i = 0;
          while (i < periods.length && dayCount < 7) {
            const period = periods[i];
            const forecastText = period.shortForecast || 'N/A';
            const humidity = await getHumidity(wfo, gridX, gridY, period.startTime);
            const tempF = period.temperatureUnit === 'F' ? period.temperature : Math.round((period.temperature * 9/5) + 32);
            const dayElement = document.createElement('div');
            dayElement.className = 'day-item';
            dayElement.innerHTML = `
              <p class="font-medium">${period.name}</p>
              <p>${period.isDaytime ? 'High' : 'Low'}: ${tempF}°F</p>
              <img src="${period.icon || `${NWS_API}/icons/land/day/skc?size=medium`}" alt="${forecastText}" class="mt-1 w-10 h-10">
              <p>${forecastText}</p>
              <p>Humidity: ${humidity}</p>
            `;
            elements.sevenDay.appendChild(dayElement);
            i++;
            if (i >= periods.length || (i % 2 === 0 && periods[i-1].isDaytime !== periods[i-2].isDaytime)) {
              dayCount++;
            }
          }

          elements.alertsCount.textContent = alerts.length;
          elements.alertsCount.classList.toggle('hidden', alerts.length === 0);
          elements.alertsList.innerHTML = alerts.length ? alerts.map((alert, index) => `
            <div class="alert-item">
              <p class="alert-title" data-alert-index="${index}">${alert.properties.headline || alert.properties.event || 'Alert'}</p>
              <p class="alert-description" id="alert-description-${index}">${alert.properties.description || 'No description available.'}</p>
            </div>
          `).join('') : '<p class="p-2 text-gray-600">No active alerts.</p>';

          document.querySelectorAll('.alert-title').forEach(title => {
            title.addEventListener('click', () => {
              const desc = document.getElementById(`alert-description-${title.dataset.alertIndex}`);
              desc.classList.toggle('active');
            });
          });

          elements.loading.classList.add('hidden');
          elements.result.classList.remove('hidden');
          elements.tabs.classList.remove('hidden');
          selectedLocation = null;
        } catch {
          elements.loading.classList.add('hidden');
          elements.error.textContent = 'Error fetching weather data.';
          elements.error.classList.remove('hidden');
          elements.starter.classList.remove('hidden');
        }
      }

      document.getElementById('auto-locate').addEventListener('click', () => {
        const geolocationMessage = document.getElementById('geolocation-message');
        const errorElement = document.getElementById('location-error');
        geolocationMessage.classList.remove('hidden');
        errorElement.classList.add('hidden');

        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            async (position) => {
              const { latitude, longitude } = position.coords;
              try {
                const locationName = await reverseGeocode(latitude, longitude);
                elements.locationInput.value = locationName;
                await fetchWeather(locationName, latitude, longitude, true);
                geolocationMessage.classList.add('hidden');
              } catch {
                geolocationMessage.classList.add('hidden');
                errorElement.textContent = 'Error fetching location.';
                errorElement.classList.remove('hidden');
              }
            },
            () => {
              geolocationMessage.classList.add('hidden');
              errorElement.textContent = 'Location access denied.';
              errorElement.classList.remove('hidden');
            },
            { timeout: 10000 }
          );
        } else {
          geolocationMessage.classList.add('hidden');
          errorElement.textContent = 'Geolocation not supported.';
          errorElement.classList.remove('hidden');
        }
      });

      document.getElementById('get-weather').addEventListener('click', () => {
        fetchWeather(elements.locationInput.value.trim());
      });
    });
  </script>
</body>
</html>
